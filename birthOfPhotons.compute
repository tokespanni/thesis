#version 430

layout(local_size_x = 1, local_size_y = 1) in;

layout(binding = 0) uniform atomic_uint counter;

struct photon
{
	vec3 color;
	float birthTime;
	vec2 speed;
	float power;
	float dummy;
};
struct light
{
	vec2 pos;
	float power;
	float c_photon;
	float i_photon_start;
	float i_photon_end;
	vec2 dummy;
};
restrict layout(std430, binding = 1) buffer photonBuffer
{
	photon photons[];
};

restrict layout(std430, binding = 2) buffer emptyIndices
{
	int ind[];
};

restrict layout(std430, binding = 3) buffer posBuffer
{
	vec2 pos[];
};

restrict readonly layout(std430, binding = 4) buffer lightSourceBuffer
{
	light lights[];
};

layout(location = 0) uniform float totalTime;
layout(location = 1) uniform int photonBirthCount;
layout(location = 2) uniform int lightSourceNum;
layout(location = 3) uniform float totalPower;

vec3 photon_pos_angle()
{
	int ind = int(gl_GlobalInvocationID.x); //which photon
	int i = 0;
	while(ind < lights[i].i_photon_start || ind > lights[i].i_photon_end) {i++;} //lightSourse index
	//i--;
	const float pi = 3.141592;
	float alpha = 2.0 * pi * float(ind - lights[i].i_photon_start) / float(lights[i].c_photon);
	return vec3(lights[i].pos, alpha);
}

void main()
{	
	uint i = atomicCounterDecrement(counter);
	
	if (i < 1073741824) //=2^30
	{
		atomicCounterIncrement(counter);
	}
	else
	{
		int index = ind[i-1073741824];
		vec3 ppa = photon_pos_angle();
		pos[index] = ppa.xy;
		photon p;
		p.speed = vec2(cos(ppa.z), sin(ppa.z));
		p.birthTime = totalTime;
		p.color = vec3(1.0, 0, 0);
		p.power = totalPower / photonBirthCount;
		p.dummy = 0;
		photons[index] = p;
	}
}

//color computing