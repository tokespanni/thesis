#version 430

layout(local_size_x = 1, local_size_y = 1) in;

layout(binding = 0) uniform atomic_uint counter;

struct photon
{
	vec3 color;
	float birthTime;
	vec2 speed;
	float power;
	float dummy;
};
struct light
{
	vec2 pos;
	float power;
	float dummy;
};
restrict layout(std430, binding = 1) buffer photonBuffer
{
	photon photons[];
};

restrict layout(std430, binding = 2) buffer emptyIndices
{
	int ind[];
};

restrict layout(std430, binding = 3) buffer posBuffer
{
	vec2 pos[];
};

restrict readonly layout(std430, binding = 4) buffer lightSourceBuffer
{
	light lights[];
};

layout(location = 0) uniform float totalTime;
layout(location = 1) uniform int photonBirthCount;
layout(location = 2) uniform int lightSourceNum;
layout(location = 3) uniform float totalPower;

float debug_light_powers[2] = {1,1};
vec2 debug_light_pos[2] = {vec2(-0.5),vec2(0.5)};

ivec3 photon_indices()
{
	float sumOfPowers = 0;
	int light_index = 0;
	while(sumOfPowers / totalPower <= gl_GlobalInvocationID.x / float(1024))
	{
		sumOfPowers += debug_light_powers[light_index];
		++light_index;
		//if(light_index>2) break; // ha ez nincs kikommentelve, akkor működik
	}
	--light_index;
	int lastplusonephotonindex = int(sumOfPowers*float(1024));
	sumOfPowers -= debug_light_powers[light_index];
	int photon_index = int(sumOfPowers*float(1024));
	
	int sumOfPhotons = lastplusonephotonindex - photon_index;
	return ivec3(light_index, photon_index, sumOfPhotons);
}

void main()
{	
	uint i = atomicCounterDecrement(counter);
	
	if (i < 1073741824) //=2^30
	{
		atomicCounterIncrement(counter);
	}
	else
	{
		const float pi = 3.141592;
		int index = ind[i-1073741824];
		ivec3 indices = photon_indices();
		pos[index] = debug_light_pos[indices.x];
		float alpha = 2.0*pi*float(gl_GlobalInvocationID.x-indices.y)/float(indices.z);
		photon p;
		p.speed = vec2(cos(alpha), sin(alpha));
		p.birthTime = totalTime;
		p.color = vec3(1.0, 0, 0);
		p.power = totalPower / photonBirthCount;
		p.dummy = 0;
		photons[index] = p;
	}
}

//color computing