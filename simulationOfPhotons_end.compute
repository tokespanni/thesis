vec3 f(vec2 uv)
{
	return ff(uv*0.5-0.5);
}

const float eps = 0.0005;

vec3 dfu(vec2 point)
{
	vec2 h = vec2(eps, 0);
	vec2 p[4] = {point-2*h, point-h, point+h, point+2*h};
	return (f(p[0]) - 8*f(p[1]) + 8*f(p[2]) - f(p[3]))/(12*h.x); //du
}

vec3 dfv(vec2 point)
{
	vec2 h = vec2(0, eps);
	vec2 p[4] = {point-2*h, point-h, point+h, point+2*h};
	return (f(p[0]) - 8*f(p[1]) + 8*f(p[2]) - f(p[3]))/(12*h.y); //dv
}

vec3 dfuu(vec2 point)
{
	vec2 h = vec2(eps, 0);
	vec2 p[4] = {point-2*h, point-h, point+h, point+2*h};
	return (dfu(p[0]) - 8*dfu(p[1]) + 8*dfu(p[2]) - dfu(p[3]))/(12*h.x);
}

vec3 dfvv(vec2 point)
{
	vec2 h = vec2(0, eps);
	vec2 p[4] = {point-2*h, point-h, point+h, point+2*h};
	return (dfv(p[0]) - 8*dfv(p[1]) + 8*dfv(p[2]) - dfv(p[3]))/(12*h.y);
}

vec3 dfuv(vec2 point)
{
	vec2 h = vec2(0, eps);
	vec2 p[4] = {point-2*h, point-h, point+h, point+2*h};
	return (dfu(p[0]) - 8*dfu(p[1]) + 8*dfu(p[2]) - dfu(p[3]))/(12*h.y);
}

vec4 F(vec4 Omega)
{
	vec2 p = Omega.xy;
	
	vec3 duu = dfuu(p);
	vec3 duv = dfuv(p);
	vec3 dvv = dfvv(p);
	mat2x3 df = mat2x3(dfu(p), dfv(p));
	mat2x3 ddu = mat2x3(duu, duv);
	mat2x3 ddv = mat2x3(duv, dvv);
	
	mat2 Gauss = transpose(df) *df;
	float E = Gauss[0][0], F = Gauss[0][1], G = Gauss[1][1];
	
	
	mat2 dGaussU = transpose(df) * ddu + transpose(ddu) * df;
	mat2 dGaussV = transpose(df) * ddv + transpose(ddv) * df;
	
	float Eu = dGaussU[0][0];
	float Ev = dGaussV[0][0];
	float Fu = dGaussU[0][1];
	float Fv = dGaussV[0][1];
	float Gu = dGaussU[1][1];
	float Gv = dGaussV[1][1];
	
	float denom = 2*determinant(Gauss);
	
	//Christoffel symbols
	
	mat2 K1 = mat2(G*Eu - 2*F*Fu + F*Ev,   G*Ev - F*Gu,
				  G*Ev - F*Gu,  2*G*Fv - G*Gu + F*Gv)/denom;
	mat2 K2 = mat2((2*E*Fu - E*Ev + F*Eu,   E*Gu - F*Ev,
				  E*Gu - F*Ev,  E*Gv - 2*F*Fv + F*Gu)/denom);
	
	vec2 v = Omega.zw;
	vec2 ddOmega = vec2(
		-K1[0][0]*v.x * v.x - 2*K1[0][1] * v.x * v.y - K1[1][1] * v.y * v.y,  
		-K2[0][0]*v.x * v.x - 2*K2[0][1] * v.x * v.y - K2[1][1] * v.y * v.y);
	return vec4(v, ddOmega);
}

vec4 Euler(vec4 posvel, float delta_t)
{
	return delta_t*F(posvel) + posvel;
}
vec4 Midpoint(vec4 yk, float h)
{
	return yk + h*F(yk+0.5*F(yk));
}

float collision_f(vec2 p)
{
	return 0.9 - length(p);
}

void main()
{	
	uint index = gl_GlobalInvocationID.x;
	if(photons[index].speed == vec2(0)) return;
	
	vec2 position = pos1[index].xy;
	vec2 velocity = photons[index].speed;
	vec4 posVel = Euler(vec4(position,velocity),deltaTime);
	
	position = posVel.xy;
	velocity = posVel.zw;
	
	if(collision_f(position) < 0)
	{
		position = vec2(0.75, 0.75);
		velocity = vec2(0);
		int i = int(atomicCounterIncrement(counter) - 1073741824);
		ind[i] = int(index);
	}
	
	pos2[index] = vec4(position,totalTime,0);
	photons[index].speed = velocity;
}